# hibernate-view-safe-fix
The project represents and  demonstrates an interestig approach to fixing  LazyInitializationException in Spring Repository and JPA generally.
 - The approach is very simple and tries solving the problem in it sroot.  LazyInitializationException  is caused by attempt to hit database (execute query) on detached proxies after  a Hibernate session. The case is very usual in MVC and REST API planning.  The typical schenario is like this: an Entyity class has a mapping (let us say one to many), where collection of referred objects is joined by and external key in table of collected objects. By default Hibernate objects initialized  as lazy: Hibernate creates proxies, which really hist database when mapped fields are requiested. This way, any mapped collection consists of proxy objects, which have underlayed queries in  Hibernate session. When a session closed, JDBC queries are unlinked and the proxy object, which must be updated, cannot be updated. The LazyInitialization exception exactly signalizes about this case.
-  Direct use of Hibernate API does not lead to such collisions, because session is opened by means of calling related API function and is closed same way, when API caller will not close a Hibernate session till a connected object is still needed.But Spring's  JPA automation, which is used in Spring's data repository under the hood, works in conjunction with JTA and has the following hierarchy of beans dependency: transaction manager<- entity manager factory<datasources+hibernate udapter. Spring authomation is able to do the dependencies build under the hood, when persistence data are provided in the application's yml or .properties file. The same can be done manually, when there is a reason, both of the ways are exposed in examples.
- But anyway, either we use Spring's data repositories (by extending JpaRepository, when Spring builds underlaying worklfow), or when we use EntityManagher directly, Spring initializes and uses any EntityManagerFactoryBean's interface implementer, which produces EntityManager (JPA staff).
  Spring  JpaRepositories uses EntityManager on lower level of its interfaces methods execution and it closes it
   after related method of JpaRepository have been called. Closing the entity manager leads to closing Hibernate session.  The same mess will
    be happened in EJB when trying use the retuende data objects on View level.
   Anyway, after EntityManageris closes underlaying Hibernate session is closed also and all proxy objects are detached and any attempt to of operation, which requires a database hit will cause laxy initialation exception
    Reattachment is a worst of can be done because kills performance of databases.
 Another approach uses tricks of Hibernate JPA definition (see https://thoughts-on-java.org/LazyInitializationexception/?ck_subscriber_id=662673854).
  It is a good approach, but from point of view of system design and problem encapsulation it leads to delegation of the problem, which was birthed oustide Hibernate (Container behavior) to Hibernate. Is  a good working data model with properly working annotations must be extended because of external causes? Where are O-L of  the SOLID? 
 - We propose another approach: problem must be solved by those, who has created it, but using proper moment in environment. Delegate pattern togetherwith chain of responsibilties will work  fine. This way, we will subsclass the EntityManager and prevent call of its close() method where it is not desired. Instead of this, we will delegate the close operation to a component, which is called, for sure after all the possible usage of returned data objects are behind. The best place for this is a simple filter, and, preciselly more- after doFilter of filter chain is called. If we have an internal list to of delegate to run on this stage, then the task is solved safely, without involving Hibernate into external problems.  
 - Fortunately Spring and Java provide the way to build the simple construction. EntityManager is produced by EntityManagerFactory, it is an interface and can be subclassed by Proxy even without CGLib. EntityManagerFactory is a bean and we can intercept its initialization using related Spring API's event BeanPostPorcessor (see CommonJPAConfigSwitch.installHibernateEntityManagerCollisionResolver()). 
 We catch the method call, which produces the EntityManager interface and on this stage, we decorate the EntityManager instance for "close()" interception and delegating the method call to another part  of system, which will be called on another layer,when the mentioned proxy object are really unnecessary. 
 The stage is  after a servlet (the DispatchServlet in Spring case) processed the request, so a filter is a good place to finalize postponed calls of entity manager.
 -At the same time we referred Spring to the configurer com.jpa.template.config.externals.view.postbuild.ConfigEntityTransactionFinal which installs the previously announced filter. The filter just  calls the interface (autowired bean)ITransactionInterceptionManagement, to finalize all works are lelated ton the current brequest. The interface is implemented and exported as a bean in the CommonJPAConfigSwitch. It exposes functionality to signalize about necessity to intercept the close() method of EnitityManager,finalize postponned operations and even provide a consumer which handles the event. The finalization method called (in the filter, particularly), to complete all postponed operations for a thread, which is associated with the current request  

The secondary goals are 
- demonstrate techniques of  routing configuration component scan routing which is managed by properties
- demonstrated techniques of deep subclassing using Spring events of component creation and initialization

